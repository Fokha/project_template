# fokha_data/models/enums.py
# =============================================================================
# TEMPLATE: Data Classification Enums
# =============================================================================
# These enums define the multi-dimensional classification system for data.
# Every piece of data can be classified by:
#   - Source: Where it comes from (live vs mock)
#   - Validity: Whether it's valid or invalid
#   - Intensity: The severity/magnitude level
#   - Origin: Internal, external, or user-generated
#   - GenerationMode: How it was generated (static vs dynamic)
#   - SchemaType: The structural type of the data
# =============================================================================

from enum import Enum, auto
from typing import Dict, Any


class DataSource(Enum):
    """
    Classifies data by its authenticity/source.

    LIVE: Real production data from actual sources
    MOCK: Simulated/fake data for testing
    HYBRID: Mix of live and mock data
    """
    LIVE = "live"
    MOCK = "mock"
    HYBRID = "hybrid"

    @property
    def is_production(self) -> bool:
        return self == DataSource.LIVE


class Validity(Enum):
    """
    Classifies data by its correctness/validity.

    VALID: Data that meets all validation rules (positive/good)
    INVALID: Data that fails validation (negative/bad)
    EDGE_CASE: Boundary conditions, edge cases
    PARTIAL: Partially valid data (some fields valid, some not)
    """
    VALID = "valid"
    INVALID = "invalid"
    EDGE_CASE = "edge_case"
    PARTIAL = "partial"

    @property
    def is_usable(self) -> bool:
        return self in (Validity.VALID, Validity.PARTIAL)


class Intensity(Enum):
    """
    Classifies data by its severity/magnitude/tension level.

    HIGH: High severity, critical, urgent
    NEUTRAL: Normal, standard, baseline
    LOW: Low severity, minor, background
    EXTREME: Outlier, exceptional case
    """
    HIGH = "high"
    NEUTRAL = "neutral"
    LOW = "low"
    EXTREME = "extreme"

    @property
    def weight(self) -> float:
        weights = {
            Intensity.EXTREME: 1.0,
            Intensity.HIGH: 0.75,
            Intensity.NEUTRAL: 0.5,
            Intensity.LOW: 0.25,
        }
        return weights.get(self, 0.5)


class Origin(Enum):
    """
    Classifies data by where it originated.

    INTERNAL: Generated by the system itself
    EXTERNAL: From external APIs, feeds, third parties
    USER: User input, user-generated content
    COMPUTED: Derived/calculated from other data
    """
    INTERNAL = "internal"
    EXTERNAL = "external"
    USER = "user"
    COMPUTED = "computed"


class GenerationMode(Enum):
    """
    Classifies how data is generated (for factory/testing).

    STATIC: Deterministic, repeatable, same output every time
    DYNAMIC: Randomized, variable output each generation
    SEEDED: Randomized but reproducible with seed
    SEQUENTIAL: Incremental/sequential generation
    """
    STATIC = "static"
    DYNAMIC = "dynamic"
    SEEDED = "seeded"
    SEQUENTIAL = "sequential"

    @property
    def is_reproducible(self) -> bool:
        return self in (GenerationMode.STATIC, GenerationMode.SEEDED, GenerationMode.SEQUENTIAL)


class SchemaType(Enum):
    """
    Classifies the structural type of the data.

    PRIMITIVE: Single value (int, str, float, bool)
    OBJECT: Key-value structure (dict)
    ARRAY: List/array of items
    NESTED: Complex nested structure
    BINARY: Binary/blob data
    """
    PRIMITIVE = "primitive"
    OBJECT = "object"
    ARRAY = "array"
    NESTED = "nested"
    BINARY = "binary"


# =============================================================================
# HELPER: Enum Serialization
# =============================================================================

def enum_to_dict(enum_value: Enum) -> Dict[str, Any]:
    """Convert an enum value to a dictionary for serialization."""
    return {
        "type": enum_value.__class__.__name__,
        "value": enum_value.value,
        "name": enum_value.name,
    }


def dict_to_enum(data: Dict[str, Any], enum_class: type) -> Enum:
    """Convert a dictionary back to an enum value."""
    return enum_class(data["value"])
